From ad0ee4482ace386b188d10559ed67382bcaf88ba Mon Sep 17 00:00:00 2001
From: Claudio Caputo <cld.cpt@gmail.com>
Date: Wed, 22 Apr 2020 17:09:31 +0200
Subject: [PATCH] new IVF porting to 10_2_15_patch2

---
 RecoVertex/AdaptiveVertexFinder/BuildFile.xml |   1 +
 .../TracksClusteringFromDisplacedSeed.h       |  23 ++-
 .../plugins/BuildFile.xml                     |   1 +
 .../plugins/InclusiveVertexFinder.h           |  64 ++++++---
 .../src/TracksClusteringFromDisplacedSeed.cc  | 134 +++++++++++++++---
 6 files changed, 172 insertions(+), 78 deletions(-)


diff --git a/RecoVertex/AdaptiveVertexFinder/BuildFile.xml b/RecoVertex/AdaptiveVertexFinder/BuildFile.xml
index feb4d957e50..89434d2c285 100644
--- a/RecoVertex/AdaptiveVertexFinder/BuildFile.xml
+++ b/RecoVertex/AdaptiveVertexFinder/BuildFile.xml
@@ -1,3 +1,4 @@
+<use   name="DataFormats/PatCandidates"/>
 <use   name="RecoVertex/KalmanVertexFit"/>
 <use   name="RecoVertex/AdaptiveVertexFit"/>
 <use   name="RecoVertex/VertexPrimitives"/>
diff --git a/RecoVertex/AdaptiveVertexFinder/interface/TracksClusteringFromDisplacedSeed.h b/RecoVertex/AdaptiveVertexFinder/interface/TracksClusteringFromDisplacedSeed.h
index c3f6e4b5cd8..87762df00a2 100644
--- a/RecoVertex/AdaptiveVertexFinder/interface/TracksClusteringFromDisplacedSeed.h
+++ b/RecoVertex/AdaptiveVertexFinder/interface/TracksClusteringFromDisplacedSeed.h
@@ -15,6 +15,9 @@
 #include "DataFormats/TrackReco/interface/TrackFwd.h"
 #include "DataFormats/VertexReco/interface/Vertex.h"
 #include "DataFormats/VertexReco/interface/VertexFwd.h"
+#include "DataFormats/PatCandidates/interface/Muon.h"
+#include "DataFormats/PatCandidates/interface/Electron.h"
+#include "DataFormats/PatCandidates/interface/PackedCandidate.h"
 #include "DataFormats/BeamSpot/interface/BeamSpot.h"
 
 #include "TrackingTools/PatternTools/interface/TwoTrackMinimumDistance.h"
@@ -24,20 +27,27 @@
 
 class TracksClusteringFromDisplacedSeed {
     public:
-    struct Cluster 
-    {       
-      GlobalPoint seedPoint;      
+    struct Cluster
+    {
+      GlobalPoint seedPoint;
       reco::TransientTrack seedingTrack;
       std::vector<reco::TransientTrack> tracks;
     };
 	TracksClusteringFromDisplacedSeed(const edm::ParameterSet &params);
-	
-	
+
+
         std::vector<Cluster> clusters(
 	  const reco::Vertex    &pv,
 	  const std::vector<reco::TransientTrack> & selectedTracks
 	 );
-	 
+
+   std::vector<Cluster> clusters(
+   	 const reco::Vertex &pv,
+   	 const std::vector<reco::TransientTrack> & selectedTracks,
+   	 const pat::MuonCollection & muons,
+      const pat::ElectronCollection & electrons
+    );
+
 
     private:
 	bool trackFilter(const reco::TrackRef &track) const;
@@ -56,4 +66,3 @@ class TracksClusteringFromDisplacedSeed {
 
 
 };
-
diff --git a/RecoVertex/AdaptiveVertexFinder/plugins/BuildFile.xml b/RecoVertex/AdaptiveVertexFinder/plugins/BuildFile.xml
index 778e25b69f0..6830359b3a7 100644
--- a/RecoVertex/AdaptiveVertexFinder/plugins/BuildFile.xml
+++ b/RecoVertex/AdaptiveVertexFinder/plugins/BuildFile.xml
@@ -1,6 +1,7 @@
 <use   name="FWCore/Framework"/>
 <use   name="DataFormats/Common"/>
 <use   name="DataFormats/VertexReco"/>
+<use   name="DataFormats/PatCandidates"/>
 <use   name="DataFormats/JetReco"/>
 <use   name="DataFormats/BTauReco"/>
 <use   name="DataFormats/BeamSpot"/>
diff --git a/RecoVertex/AdaptiveVertexFinder/plugins/InclusiveVertexFinder.h b/RecoVertex/AdaptiveVertexFinder/plugins/InclusiveVertexFinder.h
index 5012803c78c..6b1d3affd03 100644
--- a/RecoVertex/AdaptiveVertexFinder/plugins/InclusiveVertexFinder.h
+++ b/RecoVertex/AdaptiveVertexFinder/plugins/InclusiveVertexFinder.h
@@ -17,6 +17,8 @@
 #include "DataFormats/TrackReco/interface/TrackFwd.h"
 #include "DataFormats/VertexReco/interface/Vertex.h"
 #include "DataFormats/VertexReco/interface/VertexFwd.h"
+#include "DataFormats/PatCandidates/interface/Muon.h"
+#include "DataFormats/PatCandidates/interface/Electron.h"
 #include "DataFormats/BeamSpot/interface/BeamSpot.h"
 
 #include "RecoVertex/ConfigurableVertexReco/interface/ConfigurableVertexReconstructor.h"
@@ -56,8 +58,11 @@ class TemplatedInclusiveVertexFinder : public edm::stream::EDProducer<> {
             pdesc.add<unsigned int>("minHits",0);
           } else {
             pdesc.add<edm::InputTag>("tracks",edm::InputTag("generalTracks"));
-          }	  
-	  
+          }
+	  pdesc.add<edm::InputTag>("muons",edm::InputTag("slimmedMuons"));
+    pdesc.add<edm::InputTag>("electrons",edm::InputTag("slimmedElectrons"));
+    pdesc.add<bool>("useObjectForSeeding",false);
+
 	  pdesc.add<double>("maximumLongitudinalImpactParameter",0.3);
 	  pdesc.add<double>("maximumTimeSignificance",3.0);
 	  pdesc.add<double>("minPt",0.8);
@@ -105,9 +110,12 @@ class TemplatedInclusiveVertexFinder : public edm::stream::EDProducer<> {
 	bool trackFilter(const reco::Track &track) const;
         std::pair<std::vector<reco::TransientTrack>,GlobalPoint> nearTracks(const reco::TransientTrack &seed, const std::vector<reco::TransientTrack> & tracks, const reco::Vertex & primaryVertex) const;
 
-	edm::EDGetTokenT<reco::BeamSpot> 	token_beamSpot; 
+	edm::EDGetTokenT<reco::BeamSpot> 	token_beamSpot;
 	edm::EDGetTokenT<reco::VertexCollection> token_primaryVertex;
-	edm::EDGetTokenT<InputContainer>	token_tracks; 
+	edm::EDGetTokenT<InputContainer>	token_tracks;
+  edm::EDGetTokenT<pat::MuonCollection>	token_muons;
+  edm::EDGetTokenT<pat::ElectronCollection>	token_electrons;
+  bool useObjectCollection;
 	unsigned int				minHits;
 	unsigned int				maxNTracks;
 	double					maxLIP;
@@ -127,7 +135,8 @@ class TemplatedInclusiveVertexFinder : public edm::stream::EDProducer<> {
 };
 template <class InputContainer, class VTX>
 TemplatedInclusiveVertexFinder<InputContainer,VTX>::TemplatedInclusiveVertexFinder(const edm::ParameterSet &params) :
-	minHits(params.getParameter<unsigned int>("minHits")),
+  useObjectCollection(params.getParameter<bool>("useObjectForSeeding")),
+  minHits(params.getParameter<unsigned int>("minHits")),
 	maxNTracks(params.getParameter<unsigned int>("maxNTracks")),
        	maxLIP(params.getParameter<double>("maximumLongitudinalImpactParameter")),
 	maxTimeSig(params.getParameter<double>("maximumTimeSignificance")),
@@ -147,7 +156,9 @@ TemplatedInclusiveVertexFinder<InputContainer,VTX>::TemplatedInclusiveVertexFind
 	token_beamSpot = consumes<reco::BeamSpot>(params.getParameter<edm::InputTag>("beamSpot"));
 	token_primaryVertex = consumes<reco::VertexCollection>(params.getParameter<edm::InputTag>("primaryVertices"));
 	token_tracks = consumes<InputContainer>(params.getParameter<edm::InputTag>("tracks"));
-	produces<Product>();
+  token_muons = consumes<pat::MuonCollection>(params.getParameter<edm::InputTag>("muons"));
+  token_electrons = consumes<pat::ElectronCollection>(params.getParameter<edm::InputTag>("electrons"));
+  produces<Product>();
 	//produces<reco::VertexCollection>("multi");
 }
 template <class InputContainer, class VTX>
@@ -157,7 +168,7 @@ bool TemplatedInclusiveVertexFinder<InputContainer,VTX>::trackFilter(const reco:
 		return false;
 	if (track.pt() < minPt )
 		return false;
- 
+
 	return true;
 }
 
@@ -186,6 +197,14 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 	edm::Handle<InputContainer> tracks;
 	event.getByToken(token_tracks, tracks);
 
+  edm::Handle<pat::MuonCollection> muonsHandle;
+  event.getByToken(token_muons, muonsHandle);
+  const pat::MuonCollection *muons = muonsHandle.product();
+
+  edm::Handle<pat::ElectronCollection> electronsHandle;
+  event.getByToken(token_electrons, electronsHandle);
+  const pat::ElectronCollection *electrons = electronsHandle.product();
+
 	edm::ESHandle<TransientTrackBuilder> trackBuilder;
 	es.get<TransientTrackRecord>().get("TransientTrackBuilder",
 	                                   trackBuilder);
@@ -193,12 +212,12 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 
         auto recoVertices = std::make_unique<Product>();
         if(primaryVertices->size()!=0) {
-     
+
 	const reco::Vertex &pv = (*primaryVertices)[0];
 	GlobalPoint ppv(pv.position().x(),pv.position().y(),pv.position().z());
-        
+
 	std::vector<TransientTrack> tts;
-        //Fill transient track vector 
+        //Fill transient track vector
 	for(typename InputContainer::const_iterator track = tracks->begin();
 	    track != tracks->end(); ++track) {
 //TransientTrack tt = trackBuilder->build(ref);
@@ -217,7 +236,10 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 		tt.setBeamSpot(*beamSpot);
 		tts.push_back(tt);
 	}
-        std::vector<TracksClusteringFromDisplacedSeed::Cluster> clusters = clusterizer->clusters(pv,tts);
+    std::vector<TracksClusteringFromDisplacedSeed::Cluster> clusters;
+    // We could modify clusterizer such as it will use as seeds only muons or electrons tracks
+    if(useObjectCollection) clusters = clusterizer->clusters(pv,tts, *muons, *electrons);//clusters = clusterizer->clusters(pv,tts, *muons);
+    else clusters = clusterizer->clusters(pv,tts);
 
         //Create BS object from PV to feed in the AVR
 	BeamSpot::CovarianceMatrix cov;
@@ -235,13 +257,13 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
         int i=0;
 #ifdef VTXDEBUG
 
-	std::cout <<  "CLUSTERS " << clusters.size() << std::endl; 
+	std::cout <<  "CLUSTERS " << clusters.size() << std::endl;
 #endif
 
 	for(std::vector<TracksClusteringFromDisplacedSeed::Cluster>::iterator cluster = clusters.begin();
 	    cluster != clusters.end(); ++cluster,++i)
         {
-                if(cluster->tracks.size() < 2 || cluster->tracks.size() > maxNTracks ) 
+                if(cluster->tracks.size() < 2 || cluster->tracks.size() > maxNTracks )
 		     continue;
 	 	std::vector<TransientVertex> vertices;
 		if(useVertexReco) {
@@ -253,10 +275,10 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 			if(singleFitVertex.isValid())
 				vertices.push_back(singleFitVertex);
 		}
-		
+
 		// for each transient vertex state determine if a time can be measured and fill covariance
 		if( pv.covariance(3,3) > 0. ) {
-		  for(auto& vtx : vertices) {		  
+		  for(auto& vtx : vertices) {
 		    svhelper::updateVertexTime(vtx);
 		  }
 		}
@@ -273,7 +295,7 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 			std::cout << " pos: " << vv.position() << " error: " <<vv.xError() << " " << vv.yError() << " " << vv.zError() << std::endl;
 			std::cout << " time: " << vv.time() << " error: " << vv.tError() << std::endl;
 #endif
-			GlobalVector dir;  
+			GlobalVector dir;
 			std::vector<reco::TransientTrack> ts = v->originalTracks();
 			for(std::vector<reco::TransientTrack>::const_iterator i = ts.begin();
 					i != ts.end(); ++i) {
@@ -291,23 +313,23 @@ void TemplatedInclusiveVertexFinder<InputContainer,VTX>::produce(edm::Event &eve
 			if(dlen.significance() > vertexMinDLenSig  &&
 			   ( (vertexMinAngleCosine > 0) ? (vscal > vertexMinAngleCosine) : (vscal < vertexMinAngleCosine) )
 			   &&  v->normalisedChiSquared() < 10 && dlen2.significance() > vertexMinDLen2DSig)
-			{	 
+			{
 				recoVertices->push_back(*v);
 
 #ifdef VTXDEBUG
 	                        std::cout << "ADDED" << std::endl;
 #endif
                         }
-                      
+
                    }
         }
 #ifdef VTXDEBUG
 
         std::cout <<  "Final put  " << recoVertices->size() << std::endl;
-#endif  
+#endif
         }
- 
+
 	event.put(std::move(recoVertices));
 
 }
-#endif 
+#endif
diff --git a/RecoVertex/AdaptiveVertexFinder/src/TracksClusteringFromDisplacedSeed.cc b/RecoVertex/AdaptiveVertexFinder/src/TracksClusteringFromDisplacedSeed.cc
index cc6691a3378..437ff1d45ee 100644
--- a/RecoVertex/AdaptiveVertexFinder/src/TracksClusteringFromDisplacedSeed.cc
+++ b/RecoVertex/AdaptiveVertexFinder/src/TracksClusteringFromDisplacedSeed.cc
@@ -15,7 +15,7 @@ TracksClusteringFromDisplacedSeed::TracksClusteringFromDisplacedSeed(const edm::
 	maxTimeSignificance(params.getParameter<double>("maxTimeSignificance"))
 
 {
-	
+
 }
 
 std::pair<std::vector<reco::TransientTrack>,GlobalPoint> TracksClusteringFromDisplacedSeed::nearTracks(const reco::TransientTrack &seed, const std::vector<reco::TransientTrack> & tracks, const  reco::Vertex & primaryVertex) const
@@ -39,11 +39,11 @@ std::pair<std::vector<reco::TransientTrack>,GlobalPoint> TracksClusteringFromDis
 	         GlobalPoint seedPosition     = dist.points().second;
 	         GlobalError seedPositionErr  = seed.impactPointState().cartesianError().position();
                  Measurement1D m = distanceComputer.distance(VertexState(seedPosition,seedPositionErr), VertexState(ttPoint, ttPointErr));
-                 GlobalPoint cp(dist.crossingPoint()); 
+                 GlobalPoint cp(dist.crossingPoint());
 
 		 double timeSig = 0.;
-		 if( primaryVertex.covariance(3,3) > 0. && 
-		     edm::isFinite(seed.timeExt()) && edm::isFinite(tt->timeExt()) ) { 
+		 if( primaryVertex.covariance(3,3) > 0. &&
+		     edm::isFinite(seed.timeExt()) && edm::isFinite(tt->timeExt()) ) {
 		   // apply only if time available and being used in vertexing
 		   const double tError = std::sqrt( std::pow(seed.dtErrorExt(),2) + std::pow(tt->dtErrorExt(),2) );
 		   timeSig = std::abs( seed.timeExt() - tt->timeExt() ) / tError;
@@ -51,15 +51,15 @@ std::pair<std::vector<reco::TransientTrack>,GlobalPoint> TracksClusteringFromDis
 
                  float distanceFromPV =  (dist.points().second-pv).mag();
                  float distance = dist.distance();
-		 GlobalVector trackDir2D(tt->impactPointState().globalDirection().x(),tt->impactPointState().globalDirection().y(),0.); 
-		 GlobalVector seedDir2D(seed.impactPointState().globalDirection().x(),seed.impactPointState().globalDirection().y(),0.); 
+		 GlobalVector trackDir2D(tt->impactPointState().globalDirection().x(),tt->impactPointState().globalDirection().y(),0.);
+		 GlobalVector seedDir2D(seed.impactPointState().globalDirection().x(),seed.impactPointState().globalDirection().y(),0.);
 		 //SK:UNUSED//    float dotprodTrackSeed2D = trackDir2D.unit().dot(seedDir2D.unit());
 
                  float dotprodTrack = (dist.points().first-pv).unit().dot(tt->impactPointState().globalDirection().unit());
                  float dotprodSeed = (dist.points().second-pv).unit().dot(seed.impactPointState().globalDirection().unit());
 
                  float w = distanceFromPV*distanceFromPV/(pvDistance*distance);
-          	 bool selected = (m.significance() < clusterMaxSignificance && 
+          	 bool selected = (m.significance() < clusterMaxSignificance &&
 				  ((clusterMinAngleCosine > 0) ? (dotprodSeed > clusterMinAngleCosine) : (dotprodSeed < clusterMinAngleCosine)) && //Angles between PV-PCAonSeed vectors and seed directions
 				  ((clusterMinAngleCosine > 0) ? (dotprodTrack > clusterMinAngleCosine) : (dotprodTrack < clusterMinAngleCosine)) && //Angles between PV-PCAonTrack vectors and track directions
 				  //dotprodTrackSeed2D > clusterMinAngleCosine && //Angle between track and seed
@@ -69,18 +69,18 @@ std::pair<std::vector<reco::TransientTrack>,GlobalPoint> TracksClusteringFromDis
 				  timeSig < maxTimeSignificance);  // absolute distance cut
 
 #ifdef VTXDEBUG
-            	    std::cout << tt->trackBaseRef().key() << " :  " << (selected?"+":" ")<< " " << m.significance() << " < " << clusterMaxSignificance <<  " &&  " << 
-                    dotprodSeed  << " > " <<  clusterMinAngleCosine << "  && " << 
-                    dotprodTrack  << " > " <<  clusterMinAngleCosine << "  && " << 
-                    dotprodTrackSeed2D  << " > " <<  clusterMinAngleCosine << "  &&  "  << 
-                    distance*distanceRatio  << " < " <<  distanceFromPV << "  crossingtoPV: " << distanceFromPV << " dis*scal " <<  distance*distanceRatio << "  <  " << distanceFromPV << " dist: " << distance << " < " << clusterMaxDistance << 
+            	    std::cout << tt->trackBaseRef().key() << " :  " << (selected?"+":" ")<< " " << m.significance() << " < " << clusterMaxSignificance <<  " &&  " <<
+                    dotprodSeed  << " > " <<  clusterMinAngleCosine << "  && " <<
+                    dotprodTrack  << " > " <<  clusterMinAngleCosine << "  && " <<
+                    dotprodTrackSeed2D  << " > " <<  clusterMinAngleCosine << "  &&  "  <<
+                    distance*distanceRatio  << " < " <<  distanceFromPV << "  crossingtoPV: " << distanceFromPV << " dis*scal " <<  distance*distanceRatio << "  <  " << distanceFromPV << " dist: " << distance << " < " << clusterMaxDistance <<
 			      << "timeSig: " << timeSig << std::endl; // cut scaling with track density
-#endif           
+#endif
                  if(selected)
                  {
                      result.push_back(*tt);
-                     seedingPoint = GlobalPoint(cp.x()*w+seedingPoint.x(),cp.y()*w+seedingPoint.y(),cp.z()*w+seedingPoint.z());  
-                     sumWeights+=w; 
+                     seedingPoint = GlobalPoint(cp.x()*w+seedingPoint.x(),cp.y()*w+seedingPoint.y(),cp.z()*w+seedingPoint.z());
+                     sumWeights+=w;
                  }
             }
        }
@@ -104,13 +104,13 @@ std::vector<TracksClusteringFromDisplacedSeed::Cluster> TracksClusteringFromDisp
 	for(std::vector<TransientTrack>::const_iterator it = selectedTracks.begin(); it != selectedTracks.end(); it++){
                 std::pair<bool,Measurement1D> ip = IPTools::absoluteImpactParameter3D(*it,pv);
                 if(ip.first && ip.second.value() >= min3DIPValue && ip.second.significance() >= min3DIPSignificance && ip.second.value() <= max3DIPValue && ip.second.significance() <= max3DIPSignificance)
-                  { 
+                  {
 #ifdef VTXDEBUG
                     std::cout << "new seed " <<  it-selectedTracks.begin() << " ref " << it->trackBaseRef().key()  << " " << ip.second.value() << " " << ip.second.significance() << " " << it->track().hitPattern().trackerLayersWithMeasurement() << " " << it->track().pt() << " " << it->track().eta() << std::endl;
 #endif
-                    seeds.push_back(*it);  
+                    seeds.push_back(*it);
                   }
- 
+
 	}
 
         std::vector< Cluster > clusters;
@@ -126,12 +126,100 @@ std::vector<TracksClusteringFromDisplacedSeed::Cluster> TracksClusteringFromDisp
 //                if(ntracks.first.size() == 0 || ntracks.first.size() > maxNTracks ) continue;
                 ntracks.first.push_back(*s);
 	        Cluster aCl;
-                aCl.seedingTrack = *s;		
-                aCl.seedPoint = ntracks.second; 
-	        aCl.tracks = ntracks.first; 
-                clusters.push_back(aCl); 
+                aCl.seedingTrack = *s;
+                aCl.seedPoint = ntracks.second;
+	        aCl.tracks = ntracks.first;
+                clusters.push_back(aCl);
        }
-	 	
+
 return clusters;
 }
 
+std::vector<TracksClusteringFromDisplacedSeed::Cluster> TracksClusteringFromDisplacedSeed::clusters(
+	 const reco::Vertex &pv,
+	 const std::vector<reco::TransientTrack> & selectedTracks,
+	 const pat::MuonCollection & muons,
+   const pat::ElectronCollection & electrons
+ ){
+
+	 using namespace reco;
+	 std::vector<TransientTrack> seeds;
+
+	 for (auto& ttrack: selectedTracks){
+		 double tt_pt = ttrack.track().pt();
+		 double tt_eta = ttrack.track().eta();
+     std::pair<bool,Measurement1D> ip = IPTools::absoluteImpactParameter3D(ttrack,pv);
+     bool muon_match = false;
+     bool ele_match = false;
+
+     for(auto& electron: electrons){
+       for(edm::Ref<pat::PackedCandidateCollection> cand : electron.associatedPackedPFCandidates()){
+    		 if(!cand || !(cand->bestTrack()) ) continue;
+    		 double pseudoTrack_pt = cand->bestTrack()->pt();
+    		 double pseudoTrack_eta = cand->bestTrack()->eta();
+
+  		   float dpt = fabs(tt_pt - pseudoTrack_pt);
+  		   float deta = fabs(tt_eta - pseudoTrack_eta);
+
+  		 if(ip.first && ip.second.value() >= min3DIPValue && ip.second.significance() >= min3DIPSignificance &&
+  				ip.second.value() <= max3DIPValue && ip.second.significance() <= max3DIPSignificance &&
+  			  (dpt < 0.001 && deta < 0.001 && cand->charge()!=0) ){
+
+
+  	         #ifdef VTXDEBUG
+             std::cout << "--- Electron PF track pt: "<< pseudoTrack_pt << "  Electron PF track eta: "<< pseudoTrack_eta << std::endl;
+             std::cout << "---- Track pt: " << tt_pt  << " Track eta: " << tt_eta << std::endl;
+             std::cout << "new seed ref " << ttrack.trackBaseRef().key()  << " " << ip.second.value() << " " << ip.second.significance()
+             << " " << ttrack.track().hitPattern().trackerLayersWithMeasurement() << std::endl;
+             #endif
+             ele_match = true;
+           }
+         }
+       }
+
+       for(auto& muon: muons){
+
+         const pat::PackedCandidate* cand = dynamic_cast<const pat::PackedCandidate*>(muon.sourceCandidatePtr(0).get());
+         if(!cand || !(cand->bestTrack()) ) continue;
+         double pseudoTrack_pt = cand->bestTrack()->pt();
+         double pseudoTrack_eta = cand->bestTrack()->eta();
+
+         float dpt = fabs(tt_pt - pseudoTrack_pt);
+  		   float deta = fabs(tt_eta - pseudoTrack_eta);
+
+         if(ip.first && ip.second.value() >= min3DIPValue && ip.second.significance() >= min3DIPSignificance &&
+    				ip.second.value() <= max3DIPValue && ip.second.significance() <= max3DIPSignificance &&
+    			  (dpt < 0.001 && deta < 0.001) ){
+
+    	         #ifdef VTXDEBUG
+               std::cout << "--- Muon PF track pt: " << pseudoTrack_pt << "  Muon PF track eta: "<< pseudoTrack_eta << std::endl;
+               std::cout << "---- Track pt: " << tt_pt  << " Track eta: " << tt_eta << std::endl;
+               std::cout << "new seed ref " << it->trackBaseRef().key()  << " " << ip.second.value() << " " << ip.second.significance()
+               << " " << it->track().hitPattern().trackerLayersWithMeasurement() << std::endl;
+               #endif
+               muon_match = true;
+             }
+       }
+       if (ele_match || muon_match) seeds.push_back(ttrack);
+     }
+
+
+
+	 std::vector< Cluster > clusters;
+	 int i = 0;
+	 for(std::vector<TransientTrack>::const_iterator s = seeds.begin(); s != seeds.end(); ++s, ++i){
+		 #ifdef VTXDEBUG
+		 std::cout << "Seed N. "<<i <<   std::endl;
+		 #endif // VTXDEBUG
+		 std::pair<std::vector<reco::TransientTrack>,GlobalPoint>  ntracks = nearTracks(*s,selectedTracks,pv);
+		 //std::cout << ntracks.first.size() << " " << ntracks.first.size()  << std::endl;
+		 //if(ntracks.first.size() == 0 || ntracks.first.size() > maxNTracks ) continue;
+		 ntracks.first.push_back(*s);
+		 Cluster aCl;
+		 aCl.seedingTrack = *s;
+		 aCl.seedPoint = ntracks.second;
+		 aCl.tracks = ntracks.first;
+		 clusters.push_back(aCl);
+	 }
+	 return clusters;
+}
-- 
2.17.0

